# 응답속도 향상을 위한 단계별 개발 전략 (1~10)

> 목적: 특정 목표시간(예: 10초) 달성 여부와 무관하게, **순수하게 응답속도(Latency) 개선**을 위한 개발 계획을 단계적으로 수립한다.

## 진행 체크 영역

- [-] 1단계: 현행 성능 계측 표준화 (진행 중)
- [ ] 2단계: 출력 토큰 정책 최적화
- [ ] 3단계: 프롬프트 경량화
- [ ] 4단계: 검색 단계 최적화 (Top-K/Chunk/인덱스)
- [ ] 5단계: 재랭킹 경량화/조건부 실행
- [ ] 6단계: 모델 라우팅(질문 난이도 기반)
- [ ] 7단계: 캐시 계층 도입(질문/검색/생성)
- [ ] 8단계: 추론 엔진/서빙 파라미터 튜닝
- [ ] 9단계: 동시성·큐·백프레셔 제어
- [ ] 10단계: 운영 자동화(성능 회귀 방지)

> 체크 규칙
> - 진행 시작: `[ ]` → `[-]`
> - 단계 완료: `[-]` → `[x]`

## 전제 및 범위
- 현재 운영 환경의 모델/인프라를 기준으로, 병목 구간(검색, 재랭킹, 생성, 렌더링) 전반을 최적화한다.
- 각 단계는 독립 적용 가능하지만, **1→10 순서**로 진행할수록 누적 개선 효과가 크다.
- 모든 단계에서 측정 지표를 동일하게 유지해 개선 효과를 계량화한다.

## 공통 측정 지표(필수)
- E2E Latency (질문 입력~최종 렌더링 완료)
- TTFT (Time To First Token)
- TPS (Tokens Per Second)
- Retrieval Time, Re-rank Time, Generation Time
- P50 / P95 / P99

---

## 단계별 실행 표

| 단계 | 전략명 | 상세 내용 | 개발 내용 | 작업 내용(실행/검증) | 기대 효과 | 리스크/유의사항 |
|---|---|---|---|---|---|---|
| 1 | **현행 성능 계측 표준화** | 최적화 전후 비교가 가능하도록 트레이싱/메트릭 표준을 먼저 고정 | API 미들웨어에 요청 ID, 단계별 타이머 삽입. 로그 스키마 통일 | 1) 단계별 타이머 삽입 2) 대시보드 구성 3) 기준 부하 시나리오 생성 | 병목 구간 명확화, 무의미한 튜닝 방지 | 계측 오버헤드가 커지지 않도록 샘플링/비동기 로깅 필요 |
| 2 | **출력 토큰 정책 최적화** | 생성 토큰 수가 Latency를 직접 증가시키므로 길이/형식 정책을 최적화 | 모델 호출 파라미터(max tokens, stop, temperature) 프로파일 분리(요약형/분석형) | 1) 답변 템플릿 단축 2) 중복 문장 억제 규칙 3) 토큰 사용량 리포트 자동화 | 생성 시간 즉시 단축, 응답 일관성 개선 | 과도한 축소 시 답변 품질 저하 가능 |
| 3 | **프롬프트 경량화** | 시스템/개발자 프롬프트의 장문 지시문을 구조화·압축 | 프롬프트 모듈화(공통 규칙/도메인 규칙/질문별 규칙). 불필요 문구 제거 | 1) 프롬프트 길이 측정 2) A/B 테스트 3) 품질 체크리스트 운영 | TTFT 및 전체 생성시간 개선 | 규칙 삭제 시 안전성/정확성 저하 가능 |
| 4 | **검색 단계 최적화 (Top-K/Chunk/인덱스)** | 과도한 검색 결과와 긴 Chunk가 후단 생성 지연을 유발 | 질의 유형별 Top-K 동적 조정, Chunk size/overlap 재설계, 인덱스 점검 | 1) Top-K 후보군 실험 2) Chunk 재색인 3) 검색 시간·정확도 비교 | Retrieval+Generation 동시 개선 | Top-K 과소 시 근거 누락 위험 |
| 5 | **재랭킹 경량화/조건부 실행** | 재랭킹은 정확도는 높지만 지연이 큰 구간 | 경량 re-ranker 도입, 조건부 re-rank(애매한 질의만 수행) | 1) 임계치 기반 분기 2) 후보 개수 축소(예: 20→8) 3) 품질 회귀 테스트 | Re-rank 시간 대폭 단축 | 분기 로직 오류 시 정확도 저하 |
| 6 | **모델 라우팅(질문 난이도 기반)** | 모든 질문에 동일 고비용 모델 사용을 지양 | 난이도 분류기(규칙+경량 모델)로 3B/7B/8B 경로 분기 | 1) 라우팅 정책 설계 2) 실패 시 상위 모델 fallback 3) 라우팅 로그 분석 | 평균 지연 크게 감소, 비용 절감 | 분류 오탐 시 품질 변동 가능 |
| 7 | **캐시 계층 도입(질문/검색/생성)** | 반복 요청은 캐시가 가장 빠른 개선 수단 | Semantic cache + exact match cache + retrieval cache 구성 | 1) 캐시 키 설계 2) TTL/무효화 정책 3) 캐시 hit율 모니터링 | 재질의 응답속도 급감, GPU 부하 완화 | 오래된 캐시로 최신성 저하 가능 |
| 8 | **추론 엔진/서빙 파라미터 튜닝** | 동일 하드웨어에서도 엔진 설정으로 속도 편차 큼 | 스레드, batch, gpu layers, KV cache, 메모리 맵 전략 튜닝 | 1) 파라미터 그리드 테스트 2) 최적 프리셋 저장 3) 롤백 가능한 배포 | TPS 상승, TTFT 개선 | 과도한 튜닝 시 OOM/불안정 발생 |
| 9 | **동시성·큐·백프레셔 제어** | 과도한 동시 요청은 tail latency(P95/P99) 악화 | 워커 풀/큐 길이 제한, 요청 우선순위, 타임아웃/취소 전파 적용 | 1) 큐 정책 적용 2) SLA 기반 우선순위 3) 취소 토큰 전달 | 피크 시간대 지연 안정화 | 제한 정책이 강하면 처리량 저하 가능 |
| 10 | **운영 자동화(성능 회귀 방지)** | 개선 후에도 업데이트로 재악화될 수 있어 자동 감시 필요 | CI에 성능 회귀 테스트 추가, 임계치 초과 시 배포 차단 | 1) 기준 시나리오 자동 실행 2) 회귀 경보 3) 주간 성능 리포트 | 지속적 성능 유지, 품질-속도 균형 확보 | 테스트 데이터 편향 시 판단 오류 가능 |

---

## 권장 진행 방식 (실행 로드맵)

| 기간 | 핵심 단계 | 목표 |
|---|---|---|
| 1주차 | 1~3단계 | 계측 기반 확보 + 생성 구간 즉시 단축 |
| 2주차 | 4~6단계 | 검색/재랭킹/모델선택 최적화로 구조적 지연 감소 |
| 3주차 | 7~8단계 | 캐시·엔진 튜닝으로 평균/체감 속도 동시 개선 |
| 4주차 | 9~10단계 | 피크 안정성 및 회귀 방지 체계 완성 |

## 산출물 체크리스트
- 단계별 설계 문서(파라미터/정책/롤백 기준)
- 실험 결과표(A/B, P50/P95/P99, 품질 평가)
- 운영 대시보드(단계별 Latency 분해)
- 배포/롤백 런북
- 회귀 테스트 리포트

## 완료 기준(Definition of Done)
- 단계별로 **적어도 1개 이상 지연 지표**가 통계적으로 유의하게 개선
- 품질 지표(정확도/근거충실도) 하락이 허용 범위 이내
- 운영 중 재현 가능한 설정값(버전/파라미터/시드) 문서화 완료
